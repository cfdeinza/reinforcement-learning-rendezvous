"""
The purpose of this script is to plot the Rendezvous3DOF trajectories generated by the evaluate_policy function.
The callback in evaluate_policy() generates a pickle dictionary that contains all the attributes of the environment.
To run this script from the command line, use: `python plot_trajectory.py`
Read the get_args() function to see which arguments are required.

Functions:
- save_images() saves each time step of the trajectory as a png image.
- save_gif() combines the saved images into a gif.
- plot_animation() creates an interactive 3D animation of the trajectory.
- plot_2d() creates 2D plots of the position, velocity and control inputs as a function of time.
"""

import argparse
import time
from plot_attitude_trajectory import generate_slider
from plot_trajectory_utils import *
import os
from PIL import Image
import sys


def save_images(args, data, i_0=0, i_end=None):
    """
    Save images of every point in the trajectory. The images are saved in images\\<trajectory_name> as img<#>.png \n
    :param args: Namespace containing the arguments from the command line.
    :param data: Dictionary containing the trajectory data.
    :param i_0: Starting index to make images from.
    :param i_end: Last index to make images from.
    :return: None
    """

    # Chaser position data:
    x = data['trajectory'][0]
    y = data['trajectory'][1]
    z = data['trajectory'][2]

    if i_end is None:
        i_end = x.size

    # Check that the required info about the target is available:
    lim, target_radius, cone_half_angle, w_norm, w_mag = get_trajectory_data(data)

    # Create traces:
    corridor_axis = data['trajectory'][6:, i_0]  # HACK: this won't work if the format of trajectory is changed
    assert corridor_axis.size == 3, f'Corridor axis should be 3d vector. Received {corridor_axis.size}'

    # Target body:
    target_x, target_y, target_z = create_sat_points(0, 0, 0, vec=corridor_axis)
    target_body, target_edges = create_sat(target_x, target_y, target_z, name='Target')

    # Keep-out zone (surface object):
    koz_x, koz_y, koz_z = create_koz_points(target_radius, cone_half_angle, corridor_axis)
    koz = create_koz(koz_x, koz_y, koz_z, opacity=1, legend=False)

    # Create Trajectory (Scatter3d object):
    chaser_trajectory = go.Scatter3d(x=x[0:i_0], y=y[0:i_0], z=z[0:i_0],
                                     mode='lines',
                                     line={'color': 'rgb(50,150,50)', 'dash': 'solid', 'width': 4},
                                     # marker={'size': 2, 'color': 'rgb(50,50,50)'},
                                     name='Trajectory',
                                     showlegend=False)

    # Create Chaser:
    chaser_x, chaser_y, chaser_z = create_cube_points(x[i_0], y[i_0], z[i_0])
    chaser_body, chaser_edges = create_cube(chaser_x, chaser_y, chaser_z, name='Chaser')

    # Create a directory for the output images:
    _, dataname = os.path.split(args.path)
    out_directory = os.path.join('images', str(dataname.split('.')[0]))
    if not os.path.exists(out_directory):
        os.mkdir(out_directory)

    # Create a figure:
    fig_dict = {
        'data': [koz, chaser_trajectory, chaser_body, chaser_edges, target_body, target_edges],
        'layout': {
            'scene': dict(
                xaxis=dict(range=[-lim, lim]), xaxis_showspikes=False,  # zerolinecolor="black"
                yaxis=dict(range=[-lim, lim]), yaxis_showspikes=False,
                zaxis=dict(range=[-lim, lim]), zaxis_showspikes=False),
            'width': 800,
            'scene_aspectmode': 'cube',
            'scene_camera': define_camera(eye=[-0.2, -0.2, 0.4]),  # 'title': 'Rendezvous trajectory',
        }}
    fig = go.Figure(fig_dict)

    # Iterate through each time step:
    for i in range(i_0, i_end):
        corridor_axis = data['trajectory'][6:, i]
        # Update traces:
        # Keep-out zone:
        koz_x, koz_y, koz_z = create_koz_points(target_radius, cone_half_angle, corridor_axis)
        fig.update_traces(patch={'x': koz_x, 'y': koz_y, 'z': koz_z}, selector=0)
        # Trajectory:
        fig.update_traces(patch={'x': x[0:i], 'y': y[0:i], 'z': z[0:i]}, selector=1)
        # Chaser:
        chaser_x, chaser_y, chaser_z = create_cube_points(x[i], y[i], z[i])
        fig.update_traces(patch={'x': chaser_x, 'y': chaser_y, 'z': chaser_z}, selector=2)
        chaser_edge_x, chaser_edge_y, chaser_edge_z = create_cube_edge_points(chaser_x, chaser_y, chaser_z)
        fig.update_traces(patch={'x': chaser_edge_x, 'y': chaser_edge_y, 'z': chaser_edge_z}, selector=3)
        # Target:
        target_x, target_y, target_z = create_sat_points(0, 0, 0, corridor_axis)
        fig.update_traces(patch={'x': target_x, 'y': target_y, 'z': target_z}, selector=4)
        target_edge_x, target_edge_y, target_edge_z = create_sat_edge_points(target_x, target_y, target_z)
        fig.update_traces(patch={'x': target_edge_x, 'y': target_edge_y, 'z': target_edge_z}, selector=5)

        # Save as image:
        print(f'Saving images: {i}/{i_end-1}', end='\r')
        fig.write_image(os.path.join(out_directory, f'img{i}.png'))

    print(f'\nImages saved in {out_directory}')

    return


def save_gif(args, start_img=0, end_img=179):
    """
    Save the images of the trajectory as a gif file in plots\\<trajectory_name>.gif.
    To crop the gif, check out https://ezgif.com/crop \n
    :param args: Namespace containing the arguments from the command line.
    :param start_img: # of the first image to be included in the gif.
    :param end_img: # of the last image to be included in the gif.
    :return: None
    """

    # Directory of the images:
    _, dataname = os.path.split(args.path)
    directory = os.path.join('images', str(dataname.split('.')[0]))

    images = []
    missing = []
    available = []
    for i in range(start_img, end_img+1):
        try:
            images.append(Image.open(os.path.join(directory, f'img{i}.png')))
            available.append(i)
        except FileNotFoundError:
            missing.append(i)

    if len(missing) > 0:
        # print(f'Missing images: {missing}')
        print(f'Using available images: {available}')

    path = os.path.join('plots', str(dataname.split('.')[0]) + '.gif')
    print(f'Saving gif in {path}')
    images[0].save(path, save_all=True, append_images=images[1:], duration=100, loop=0)
    return


def plot_animation(args, data):
    """
    Make a 3d plotly animation showing the trajectory of the chaser around the target.\n
    :param args: Namespace containing the arguments from the command line.
    :param data: Dictionary containing the trajectory data.
    :return: None
    """

    # Chaser position data:
    x = data['trajectory'][0]
    y = data['trajectory'][1]
    z = data['trajectory'][2]

    # Check that the required info about the target is available:
    lim, target_radius, cone_half_angle, w_norm, w_mag = get_trajectory_data(data)

    # Create traces:
    corridor_axis = data['trajectory'][6:, -1]
    assert corridor_axis.size == 3, f'Corridor axis should be 3d vector. Received {corridor_axis.size}'

    # Keep-out zone:
    koz_x, koz_y, koz_z = create_koz_points(target_radius, cone_half_angle, corridor_axis)
    koz = create_koz(koz_x, koz_y, koz_z, opacity=1, legend=True)

    # Target body:
    target_x, target_y, target_z = create_sat_points(0, 0, 0, vec=corridor_axis)
    target_body, target_edges = create_sat(target_x, target_y, target_z, name='Target')

    # Chaser trajectory:
    chaser_trajectory = go.Scatter3d(x=x, y=y, z=z,
                                     mode='lines',
                                     line={'color': 'rgb(50,150,50)', 'dash': 'solid', 'width': 4},
                                     # marker={'size': 2, 'color': 'rgb(50,50,50)'},
                                     name='Trajectory',
                                     showlegend=True)

    # Chaser:
    chaser_x, chaser_y, chaser_z = create_cube_points(x[-1], y[-1], z[-1])
    chaser_body, chaser_edges = create_cube(chaser_x, chaser_y, chaser_z, name='Chaser')

    # Make the figure:
    fig_dict = {
        'data': [koz, chaser_trajectory, chaser_body, chaser_edges, target_body, target_edges],
        'layout': {
            'scene': dict(
                xaxis=dict(range=[-lim, lim]), xaxis_showspikes=False,  # zerolinecolor="black"
                yaxis=dict(range=[-lim, lim]), yaxis_showspikes=False,
                zaxis=dict(range=[-lim, lim]), zaxis_showspikes=False),
            'width': 800,
            'scene_aspectmode': 'cube',
            'scene_camera': define_camera(),
            'title': 'Rendezvous trajectory',
            'updatemenus': [{
                "buttons": [
                    {
                        "args": [None, {"frame": {"duration": 0},
                                        'mode': 'immediate', "fromcurrent": True,
                                        "transition": {"duration": 0}}],
                        "label": "Play",
                        "method": "animate"},
                    {
                        "args": [[None], {"frame": {"duration": 0},
                                          "mode": "immediate",
                                          "transition": {"duration": 0}}],
                        "label": "Pause",
                        "method": "animate"}],
                'type': 'buttons'}]},
        'frames': []}
    fig = go.Figure(fig_dict)

    # Update the time interval between the animation's frames:
    # dt = data['dt']
    fig.layout.updatemenus[0].buttons[0].args[1]["frame"]["duration"] = 0  # dt * 200
    # fig.layout.updatemenus[0].buttons[0].args[1]['frame']['duration'] = 30
    # fig.layout.updatemenus[0].buttons[0].args[1]['transition']['duration'] = 5

    # Create the frames:
    frames = []
    for i in range(0, len(x)):
        corridor_axis = data['trajectory'][6:, i]
        # Update the keep-out zone:
        koz_x, koz_y, koz_z = create_koz_points(target_radius, cone_half_angle, vec=corridor_axis)
        current_koz = go.Surface(x=koz_x, y=koz_y, z=koz_z)

        # Update the target:
        # TODO: Fix the target rotation.
        target_x, target_y, target_z = create_sat_points(0, 0, 0, vec=corridor_axis)
        target_body, target_edges = create_sat(target_x, target_y, target_z)

        # Update the trajectory:
        current_trajectory = go.Scatter3d(x=x[0:i+1], y=y[0:i+1], z=z[0:i+1])

        # Update the chaser:
        chaser_x, chaser_y, chaser_z = create_cube_points(x[i], y[i], z[i])
        current_body, current_edges = create_cube(chaser_x, chaser_y, chaser_z)

        # Define new frame:
        frame = {"data": [current_koz, current_trajectory, current_body, current_edges, target_body, target_edges],
                 "name": str(i), "traces": [0, 1, 2, 3, 4, 5]}  # 'traces' indicates which trace we are updating.
        frames.append(frame)
    fig.frames = tuple(frames)
    sliders = generate_slider(fig)
    fig.update_layout(sliders=sliders)

    if args.save:  # Save the animation as an html file
        _, dataname = os.path.split(args.path)
        filename = str(dataname.split('.')[0]) + '_anim.html'
        fig.write_html(os.path.join('plots', filename))
        print(f'Animation saved in: "plots\{filename}"')

    if args.show:  # Display the animation
        fig.show()

    return


def plot2d(args, data):
    """
    Plot a 2d matplotlib figure to show the position and the control inputs of the chaser over time.\n
    :param args: Namespace containing the arguments from the command line.
    :param data: Dictionary containing the trajectory data.
    :return: None
    """

    if 'trajectory' in data:
        states = data['trajectory']
    else:
        states = data['state']
    x, y, z = states[0], states[1], states[2]
    vx, vy, vz = states[3], states[4], states[5]
    pos, vel = states[0:3], states[3:]

    # Create a matplotlib figure with two subplots:
    fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(12, 6))

    # Plot the position of the chaser over time:
    t = range(len(x))
    plot_2dcomponents(ax1, t, x, y, z, labels=['x', 'y', 'z'],
                      xlabel='Time (s)', ylabel='Distance (m)', title='Position')
    # Plot the overall distance from the target:
    dist = np.linalg.norm(pos, axis=0)
    ax1.plot(t, dist, 'k--', label='Overall'), ax1.legend()

    # Plot the velocity of the chaser over time:
    plot_2dcomponents(ax2, t, vx, vy, vz, labels=[r'$v_x$', r'$v_y$', r'$v_z$'],
                      xlabel='Time (s)', ylabel='Velocity (m/s)', title='Velocity')
    # Plot the overall speed of the chaser:
    speed = np.linalg.norm(vel, axis=0)
    ax2.plot(t, speed, 'k--', label='Overall'), ax2.legend()

    # Plot the actions of the chaser over time:
    if 'actions' in data:
        actions = data['actions']
    else:
        actions = data['action']
    action_x, action_y, action_z = actions[0], actions[1], actions[2]
    t = range(len(action_x))
    sum_of_actions = sum(np.abs(action_x) + np.abs(action_y) + np.abs(action_z))
    plot_2dcomponents(ax3, t, action_x, action_y, action_z,
                      labels=['x', 'y', 'z'], xlabel='Time (s)', ylabel='Delta V (m)',
                      title='Actions. Total ' + r'$\Delta V = $' + str(round(sum_of_actions, 2)))
    # Plot the overall control effort:
    ax3.plot(t, np.linalg.norm(actions, axis=0), 'k--', label='Overall'), ax3.legend()

    plt.tight_layout()

    if args.save:  # Save the 2d plot as a png file
        _, dataname = os.path.split(args.path)
        filename = str(dataname.split('.')[0]) + '_2d.png'
        plt.savefig(os.path.join('plots', filename))
        print(f'2d plot saved in: "plots\{filename}"')

    if args.show:  # Display the 2d plot
        plt.show()
        plt.close()

    return


def get_args():
    """
    Get the arguments when running the script from the command line.
    The `path` argument is always required.
    The `type` argument determines which type of plot gets made. The options are:
        - images: run save_images()
        - gif: run save_gif()
        - anim: run plot_animation()
        - 2d: run plot2d()
        - all: run plot_animation() and plot2d()
    The `show` argument will display the plots.
    The `save` argument determines if the plots are saved or not. Note that the save_images() and save_gif() functions
    will always save the outputs.\n
    :return: Namespace containing the arguments.
    """
    parser = argparse.ArgumentParser()
    parser.add_argument('--path', dest='path', type=str, default='',
                        help='Path to the data file.')
    parser.add_argument('--type', dest='type', type=str, default='all',
                        help='Type of plot. Default creates animation and 2d plot ')
    parser.add_argument('--save', dest='save', type=bool, nargs='?', const=True, default=False,
                        help='Use this flag to save the plots.')
    parser.add_argument('--show', dest='show', type=bool, nargs='?', const=True, default=False,
                        help='Use this flag to show the plots.')
    args = parser.parse_args()

    return args


if __name__ == '__main__':
    start = time.perf_counter()
    arguments = get_args()
    trajectory_data = load_data(arguments)
    if not arguments.show:
        print('Call "--show" to display the plots.')

    if not arguments.save:
        print('Call "--save" to save the plots.')

    if arguments.type == 'images':
        save_images(arguments, trajectory_data, i_0=80, i_end=90)
    elif arguments.type == 'gif':
        save_gif(arguments)
    elif arguments.type == '2d':
        plot2d(arguments, trajectory_data)
    elif arguments.type == 'anim':
        plot_animation(arguments, trajectory_data)
    elif arguments.type == 'all':
        plot_animation(arguments, trajectory_data)
        plot2d(arguments, trajectory_data)
    else:
        print('--type unknown. Exiting')
        sys.exit()

    print(f'Finished on {time.ctime()}. ({round(time.perf_counter()-start, 2)} seconds)')
